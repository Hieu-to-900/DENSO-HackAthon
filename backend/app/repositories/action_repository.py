"""
Action Recommendations Repository - Database layer for action recommendations.
Handles CRUD operations for actionable recommendations generated by LangGraph.
"""

from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, List, Optional
from uuid import UUID, uuid4

import asyncpg


class ActionRepository:
    """Repository for action recommendation operations."""

    def __init__(self, pool: asyncpg.Pool):
        """Initialize repository with database connection pool."""
        self.pool = pool

    async def create_action(
        self,
        forecast_id: Optional[UUID],
        action_type: str,
        category: str,
        title: str,
        description: str,
        priority: str,
        affected_products: List[str],
        expected_impact: Optional[str] = None,
        estimated_cost: Optional[float] = None,
        action_items: Optional[List[Dict[str, Any]]] = None,
        deadline: Optional[datetime] = None,
        assigned_to: Optional[str] = None,
        status: str = "pending",
        confidence_score: Optional[float] = None,
        related_risks: Optional[List[str]] = None,
        langgraph_job_id: Optional[UUID] = None,
    ) -> UUID:
        """Create a new action recommendation."""
        action_id = uuid4()

        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO action_recommendations (
                    id, forecast_id, action_type, category, title, description,
                    priority, affected_products, expected_impact, estimated_cost,
                    action_items, deadline, assigned_to, status, confidence_score,
                    related_risks, langgraph_job_id
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
                """,
                action_id,
                forecast_id,
                action_type,
                category,
                title,
                description,
                priority,
                affected_products,
                expected_impact,
                estimated_cost,
                action_items,
                deadline,
                assigned_to,
                status,
                confidence_score,
                related_risks,
                langgraph_job_id,
            )

        return action_id

    async def get_active_actions(
        self,
        priority: Optional[str] = None,
        category: Optional[str] = None,
        status: Optional[str] = None,
        limit: int = 20,
    ) -> List[Dict[str, Any]]:
        """Get active action recommendations with optional filters."""
        query = """
            SELECT 
                id, priority, category, title, description,
                impact, estimated_cost, deadline, 
                affected_products, action_items, status, created_at
            FROM action_recommendations
            WHERE status IN ('pending', 'in_progress', 'snoozed')
                AND (snoozed_until IS NULL OR snoozed_until < CURRENT_TIMESTAMP)
        """
        params = []
        param_count = 1

        if priority:
            query += f" AND priority = ${param_count}"
            params.append(priority)
            param_count += 1

        if category:
            query += f" AND category = ${param_count}"
            params.append(category)
            param_count += 1

        if status:
            query += f" AND status = ${param_count}"
            params.append(status)
            param_count += 1

        query += f"""
            ORDER BY 
                CASE priority
                    WHEN 'high' THEN 1
                    WHEN 'medium' THEN 2
                    WHEN 'low' THEN 3
                END,
                deadline ASC NULLS LAST
            LIMIT ${param_count}
        """
        params.append(limit)

        async with self.pool.acquire() as conn:
            rows = await conn.fetch(query, *params)
            return [dict(row) for row in rows]

    async def get_action_by_id(self, action_id: UUID) -> Optional[Dict[str, Any]]:
        """Get a single action by ID."""
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                SELECT * FROM action_recommendations WHERE id = $1
                """,
                action_id,
            )
            return dict(row) if row else None

    async def update_action_status(
        self,
        action_id: UUID,
        status: str,
        completed_at: Optional[datetime] = None,
        notes: Optional[str] = None,
    ) -> bool:
        """Update action status and completion details."""
        async with self.pool.acquire() as conn:
            result = await conn.execute(
                """
                UPDATE action_recommendations
                SET 
                    status = $2,
                    completed_at = $3,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = $1
                """,
                action_id,
                status,
                completed_at,
            )
            return result == "UPDATE 1"

    async def assign_action(self, action_id: UUID, assigned_to: str) -> bool:
        """Assign an action to a user."""
        async with self.pool.acquire() as conn:
            result = await conn.execute(
                """
                UPDATE action_recommendations
                SET 
                    assigned_to = $2,
                    status = 'in-progress',
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = $1
                """,
                action_id,
                assigned_to,
            )
            return result == "UPDATE 1"

    async def get_actions_by_forecast(
        self, forecast_id: UUID
    ) -> List[Dict[str, Any]]:
        """Get all actions associated with a forecast."""
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                """
                SELECT * FROM action_recommendations
                WHERE forecast_id = $1
                ORDER BY 
                    CASE priority
                        WHEN 'critical' THEN 1
                        WHEN 'high' THEN 2
                        WHEN 'medium' THEN 3
                        WHEN 'low' THEN 4
                    END,
                    created_at DESC
                """,
                forecast_id,
            )
            return [dict(row) for row in rows]

    async def get_actions_by_job(self, job_id: UUID) -> List[Dict[str, Any]]:
        """Get all actions from a specific LangGraph job."""
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                """
                SELECT * FROM action_recommendations
                WHERE langgraph_job_id = $1
                ORDER BY created_at DESC
                """,
                job_id,
            )
            return [dict(row) for row in rows]

    async def get_overdue_actions(self) -> List[Dict[str, Any]]:
        """Get actions that are past their deadline."""
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                """
                SELECT * FROM action_recommendations
                WHERE status IN ('pending', 'in-progress')
                  AND deadline < CURRENT_TIMESTAMP
                ORDER BY priority DESC, deadline ASC
                """
            )
            return [dict(row) for row in rows]

    async def get_action_statistics(self) -> Dict[str, Any]:
        """Get action recommendation statistics."""
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                SELECT 
                    COUNT(*) FILTER (WHERE status = 'pending') as pending_count,
                    COUNT(*) FILTER (WHERE status = 'in-progress') as in_progress_count,
                    COUNT(*) FILTER (WHERE status = 'completed') as completed_count,
                    COUNT(*) FILTER (WHERE priority = 'critical') as critical_count,
                    COUNT(*) FILTER (WHERE priority = 'high') as high_count,
                    AVG(confidence_score) as avg_confidence,
                    SUM(estimated_cost) FILTER (WHERE status != 'cancelled') as total_estimated_cost
                FROM action_recommendations
                WHERE created_at >= CURRENT_DATE - INTERVAL '30 days'
                """
            )
            return dict(row) if row else {}

    async def bulk_create_actions(
        self, actions: List[Dict[str, Any]]
    ) -> List[UUID]:
        """Create multiple actions in a single transaction."""
        action_ids = [uuid4() for _ in actions]

        async with self.pool.acquire() as conn:
            async with conn.transaction():
                rows = [
                    (
                        action_ids[i],
                        action.get("forecast_id"),
                        action["action_type"],
                        action["category"],
                        action["title"],
                        action["description"],
                        action["priority"],
                        action["affected_products"],
                        action.get("expected_impact"),
                        action.get("estimated_cost"),
                        action.get("action_items"),
                        action.get("deadline"),
                        action.get("assigned_to"),
                        action.get("status", "pending"),
                        action.get("confidence_score"),
                        action.get("related_risks"),
                        action.get("langgraph_job_id"),
                    )
                    for i, action in enumerate(actions)
                ]

                await conn.executemany(
                    """
                    INSERT INTO action_recommendations (
                        id, forecast_id, action_type, category, title, description,
                        priority, affected_products, expected_impact, estimated_cost,
                        action_items, deadline, assigned_to, status, confidence_score,
                        related_risks, langgraph_job_id
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
                    """,
                    rows,
                )

        return action_ids
